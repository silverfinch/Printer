import numpy as np
import math

class SliceLine:
	def __init__(self,endpoints,normal):
		self.startPoint = SlicerGeometries.Point(endpoints[0][0],endpoints[0][1],endpoints[0][2])
		self.endPoint = SlicerGeometries.Point(endpoints[1][0],endpoints[1][1],endpoints[1][2])
		self.startPoint.setLine(self)
		self.endPoint.setLine(self)
		self.normal = normal

	def otherEnd(self,point):
		if self.startPoint.isEqual(point):
			return self.endPoint
		elif self.endPoint.isEqual(point):
			return self.startPoint
		else:
			print('Point not on line')

	def flipDirection(self):
		dummy = self.startPoint
		self.startPoint = self.endPoint
		self.endPoint = dummy

	def exteriorTo(self,other):
		

class Point:
	def __init__(self,X,Y,Z):
		self.X = X
		self.Y = Y
		self.Z = Z

	def isEqual(self,point):
		if (self.X == point.X and self.Y == point.Y and self.Z == point.Z):
			return 1
		else:
			return 0

	def otherEnd(self):
		return self.Line.otherEnd

	def setLine(self,line):
		self.Line = line

class Face:
        def __init__(self, v0, v1, v2, normal):
                self.points = [v0, v1, v2]
                self.maxZ = max(v0[2],v1[2],v2[2])
                self.minZ = min(v0[2],v1[2],v2[2])
		self.normal = normal

        def isSliced(self, currentZ, zIncrement):
                upperZ = self.maxZ - self.maxZ%(zIncrement/2) + zIncrement/2
                lowerZ = self.minZ - self.minZ%(zIncrement/2)
		Zcoords = [self.points[0][2],self.points[1][2],self.points[2][2]]
		if (Zcoords[0] == Zcoords[1] == Zcoords[2]):
			return 2
                elif (currentZ <= upperZ and currentZ >= lowerZ):
                        return 1
                else:
                        return 0

        def sliceLine(self, currentZ, zIncrement):
                if (self.isSliced(self, currentZ, zIncrement) == 1):
			Zcoords = [self.points[0][2],self.points[1][2],self.points[2][2]]
                	endpoints = []
                	below = []
                	above = []
			normal = np.array([self.normal[0],self.normal[1],currentZ])
			normal = normal/numpy.linalg.norm(normal)
                	for i in range(0,3):# tells which vertices are above the current elevation and which are below
                        	print(currentZ)
                        	if (abs(currentZ-Zcoords[i]) < zIncrement/2 or currentZ-Zcoords[i] == -zIncrement/2):
# if vertices are at current elevation, then add those vertices to the slice (including upper bound, which the second condition accounts for)
                                	newpoint = self.points[i]
                                	newpoint[2] = currentZ# adjusts point Z to match actual current Z, effectively rounding to nearest Z increment
                                	endpoints.append(newpoint)
                        	elif (Zcoords[i] < currentZ):
                               		below.append(self.points[i])
                        	else:
                                	above.append(self.points[i])
                	if (not below or not above):# if no vertices below current Z or no vertices above, then this is a case
# where vertices intersect perfectly with slice and thus have already been added
                        	if (len(endpoints) == 1):
                                	endpoints.append(endpoints[0])#if a single point, make it the start and end of its own infinitesmal line
                        	return SlicerGeometries.SliceLine(endpoints,normal)

		else:
                        for i in below:
                                for j in above:
                                        newpoint = ((currentZ - i[2])/(j[2] - i[2]))*(j-i) + i# linear interpolation between upper and lower po$
                                        endpoints.append(newpoint)
                        return SlicerGeometries.SliceLine(endpoints,normal)


class preContour:
	def __init__(self,lines)
		self.unorderedLines = lines

	def reorder(self)
		contours = []
		while (len(self.unorderedLines) != 0):
			orderedLines = []
			R = []
			for line in self.unorderedLines:
				R1 = math.sqrt(line.startPoint.X**2 + line.startPoint.Y**2)
				R2 = math.sqrt(line.endPoint.X**2 + line.endPoint.Y**2)
				R.append(math.max(R1,R2))
			farthest = np.argmax(R)# index of line with farthest point
			orderedLines.append(self.unorderedLines.pop(farthest))
			currentLine = orderedLines[0]# first line has been chosen
			for x in len(self.unorderedLines):
				found = 0
				choices = []
				choiceIndices = []
				for i in len(self.unorderedLines):
					line = self.unorderedLines[i]
					if currentLine.endPoint.isEqual(line.startPoint):
						choices.append(line)
						choiceIndices.append(i)# gets choice's index in unorderedLines
						found = 1
					elif currentLine.endPoint.isEqual(line.endPoint):
						line.flipDirection
						choices.append(line)
						choiceIndices.append(i)
						found = 1
				lineAngles = []
				for choice in choices:
					lineAngles.append(math.atan2((choice.endPoint.Y - choice.startPoint.Y),(choice.endPoint.X - choice.endPoint.X)))
				bestChoice = np.argmin(lineAngles)
				orderedLines.append(choices[bestChoice])
				self.unorderedLines.delete(choiceIndices[bestChoice])
				currentLine = choices[bestChoice]
				if currentLine.endPoint.isEqual(orderedLines[0].startPoint):
					contours.append(SlicerGeometries.closedContour(orderedLines))
					break
				elif len(choices) == 0:
					print('Could not resolve contour')
					
		return contours

class closedContour:
	def __init__(self,orderedLines):
		self.lines = orderedLines

	def isInside(self,other):
		normals = []
		for line in self.lines:
			normals.append(line.normal)
		for normal in normals:
			
